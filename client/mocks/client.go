// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/ONSdigital/dp-elasticsearch/v3/client"
	health "github.com/ONSdigital/dp-healthcheck/healthcheck"
	"sync"
)

// Ensure, that ClientMock does implement client.Client.
// If this is not the case, regenerate this file with moq.
var _ client.Client = &ClientMock{}

// ClientMock is a mock implementation of client.Client.
//
//	func TestSomethingThatUsesClient(t *testing.T) {
//
//		// make and configure a mocked client.Client
//		mockedClient := &ClientMock{
//			AddDocumentFunc: func(ctx context.Context, indexName string, documentID string, document []byte, opts *client.AddDocumentOptions) error {
//				panic("mock out the AddDocument method")
//			},
//			BulkIndexAddFunc: func(ctx context.Context, action client.BulkIndexerAction, index string, documentID string, document []byte) error {
//				panic("mock out the BulkIndexAdd method")
//			},
//			BulkIndexCloseFunc: func(contextMoqParam context.Context) error {
//				panic("mock out the BulkIndexClose method")
//			},
//			BulkUpdateFunc: func(ctx context.Context, indexName string, url string, settings []byte) ([]byte, error) {
//				panic("mock out the BulkUpdate method")
//			},
//			CheckerFunc: func(ctx context.Context, state *health.CheckState) error {
//				panic("mock out the Checker method")
//			},
//			CountFunc: func(ctx context.Context, count client.Count) ([]byte, error) {
//				panic("mock out the Count method")
//			},
//			CountIndicesFunc: func(ctx context.Context, indices []string) ([]byte, error) {
//				panic("mock out the CountIndices method")
//			},
//			CreateIndexFunc: func(ctx context.Context, indexName string, indexSettings []byte) error {
//				panic("mock out the CreateIndex method")
//			},
//			DeleteIndexFunc: func(ctx context.Context, indexName string) error {
//				panic("mock out the DeleteIndex method")
//			},
//			DeleteIndicesFunc: func(ctx context.Context, indices []string) error {
//				panic("mock out the DeleteIndices method")
//			},
//			GetAliasFunc: func(ctx context.Context) ([]byte, error) {
//				panic("mock out the GetAlias method")
//			},
//			GetIndicesFunc: func(ctx context.Context, indexPatterns []string) ([]byte, error) {
//				panic("mock out the GetIndices method")
//			},
//			MultiSearchFunc: func(ctx context.Context, searches []client.Search, queryParams *client.QueryParams) ([]byte, error) {
//				panic("mock out the MultiSearch method")
//			},
//			NewBulkIndexerFunc: func(contextMoqParam context.Context) error {
//				panic("mock out the NewBulkIndexer method")
//			},
//			SearchFunc: func(ctx context.Context, search client.Search) ([]byte, error) {
//				panic("mock out the Search method")
//			},
//			UpdateAliasesFunc: func(ctx context.Context, alias string, removeIndices []string, addIndices []string) error {
//				panic("mock out the UpdateAliases method")
//			},
//		}
//
//		// use mockedClient in code that requires client.Client
//		// and then make assertions.
//
//	}
type ClientMock struct {
	// AddDocumentFunc mocks the AddDocument method.
	AddDocumentFunc func(ctx context.Context, indexName string, documentID string, document []byte, opts *client.AddDocumentOptions) error

	// BulkIndexAddFunc mocks the BulkIndexAdd method.
	BulkIndexAddFunc func(ctx context.Context, action client.BulkIndexerAction, index string, documentID string, document []byte) error

	// BulkIndexCloseFunc mocks the BulkIndexClose method.
	BulkIndexCloseFunc func(contextMoqParam context.Context) error

	// BulkUpdateFunc mocks the BulkUpdate method.
	BulkUpdateFunc func(ctx context.Context, indexName string, url string, settings []byte) ([]byte, error)

	// CheckerFunc mocks the Checker method.
	CheckerFunc func(ctx context.Context, state *health.CheckState) error

	// CountFunc mocks the Count method.
	CountFunc func(ctx context.Context, count client.Count) ([]byte, error)

	// CountIndicesFunc mocks the CountIndices method.
	CountIndicesFunc func(ctx context.Context, indices []string) ([]byte, error)

	// CreateIndexFunc mocks the CreateIndex method.
	CreateIndexFunc func(ctx context.Context, indexName string, indexSettings []byte) error

	// DeleteIndexFunc mocks the DeleteIndex method.
	DeleteIndexFunc func(ctx context.Context, indexName string) error

	// DeleteIndicesFunc mocks the DeleteIndices method.
	DeleteIndicesFunc func(ctx context.Context, indices []string) error

	// GetAliasFunc mocks the GetAlias method.
	GetAliasFunc func(ctx context.Context) ([]byte, error)

	// GetIndicesFunc mocks the GetIndices method.
	GetIndicesFunc func(ctx context.Context, indexPatterns []string) ([]byte, error)

	// MultiSearchFunc mocks the MultiSearch method.
	MultiSearchFunc func(ctx context.Context, searches []client.Search, queryParams *client.QueryParams) ([]byte, error)

	// NewBulkIndexerFunc mocks the NewBulkIndexer method.
	NewBulkIndexerFunc func(contextMoqParam context.Context) error

	// SearchFunc mocks the Search method.
	SearchFunc func(ctx context.Context, search client.Search) ([]byte, error)

	// UpdateAliasesFunc mocks the UpdateAliases method.
	UpdateAliasesFunc func(ctx context.Context, alias string, removeIndices []string, addIndices []string) error

	// calls tracks calls to the methods.
	calls struct {
		// AddDocument holds details about calls to the AddDocument method.
		AddDocument []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IndexName is the indexName argument value.
			IndexName string
			// DocumentID is the documentID argument value.
			DocumentID string
			// Document is the document argument value.
			Document []byte
			// Opts is the opts argument value.
			Opts *client.AddDocumentOptions
		}
		// BulkIndexAdd holds details about calls to the BulkIndexAdd method.
		BulkIndexAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Action is the action argument value.
			Action client.BulkIndexerAction
			// Index is the index argument value.
			Index string
			// DocumentID is the documentID argument value.
			DocumentID string
			// Document is the document argument value.
			Document []byte
		}
		// BulkIndexClose holds details about calls to the BulkIndexClose method.
		BulkIndexClose []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// BulkUpdate holds details about calls to the BulkUpdate method.
		BulkUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IndexName is the indexName argument value.
			IndexName string
			// URL is the url argument value.
			URL string
			// Settings is the settings argument value.
			Settings []byte
		}
		// Checker holds details about calls to the Checker method.
		Checker []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// State is the state argument value.
			State *health.CheckState
		}
		// Count holds details about calls to the Count method.
		Count []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Count is the count argument value.
			Count client.Count
		}
		// CountIndices holds details about calls to the CountIndices method.
		CountIndices []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Indices is the indices argument value.
			Indices []string
		}
		// CreateIndex holds details about calls to the CreateIndex method.
		CreateIndex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IndexName is the indexName argument value.
			IndexName string
			// IndexSettings is the indexSettings argument value.
			IndexSettings []byte
		}
		// DeleteIndex holds details about calls to the DeleteIndex method.
		DeleteIndex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IndexName is the indexName argument value.
			IndexName string
		}
		// DeleteIndices holds details about calls to the DeleteIndices method.
		DeleteIndices []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Indices is the indices argument value.
			Indices []string
		}
		// GetAlias holds details about calls to the GetAlias method.
		GetAlias []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetIndices holds details about calls to the GetIndices method.
		GetIndices []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IndexPatterns is the indexPatterns argument value.
			IndexPatterns []string
		}
		// MultiSearch holds details about calls to the MultiSearch method.
		MultiSearch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Searches is the searches argument value.
			Searches []client.Search
			// QueryParams is the queryParams argument value.
			QueryParams *client.QueryParams
		}
		// NewBulkIndexer holds details about calls to the NewBulkIndexer method.
		NewBulkIndexer []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// Search holds details about calls to the Search method.
		Search []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Search is the search argument value.
			Search client.Search
		}
		// UpdateAliases holds details about calls to the UpdateAliases method.
		UpdateAliases []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Alias is the alias argument value.
			Alias string
			// RemoveIndices is the removeIndices argument value.
			RemoveIndices []string
			// AddIndices is the addIndices argument value.
			AddIndices []string
		}
	}
	lockAddDocument    sync.RWMutex
	lockBulkIndexAdd   sync.RWMutex
	lockBulkIndexClose sync.RWMutex
	lockBulkUpdate     sync.RWMutex
	lockChecker        sync.RWMutex
	lockCount          sync.RWMutex
	lockCountIndices   sync.RWMutex
	lockCreateIndex    sync.RWMutex
	lockDeleteIndex    sync.RWMutex
	lockDeleteIndices  sync.RWMutex
	lockGetAlias       sync.RWMutex
	lockGetIndices     sync.RWMutex
	lockMultiSearch    sync.RWMutex
	lockNewBulkIndexer sync.RWMutex
	lockSearch         sync.RWMutex
	lockUpdateAliases  sync.RWMutex
}

// AddDocument calls AddDocumentFunc.
func (mock *ClientMock) AddDocument(ctx context.Context, indexName string, documentID string, document []byte, opts *client.AddDocumentOptions) error {
	if mock.AddDocumentFunc == nil {
		panic("ClientMock.AddDocumentFunc: method is nil but Client.AddDocument was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		IndexName  string
		DocumentID string
		Document   []byte
		Opts       *client.AddDocumentOptions
	}{
		Ctx:        ctx,
		IndexName:  indexName,
		DocumentID: documentID,
		Document:   document,
		Opts:       opts,
	}
	mock.lockAddDocument.Lock()
	mock.calls.AddDocument = append(mock.calls.AddDocument, callInfo)
	mock.lockAddDocument.Unlock()
	return mock.AddDocumentFunc(ctx, indexName, documentID, document, opts)
}

// AddDocumentCalls gets all the calls that were made to AddDocument.
// Check the length with:
//
//	len(mockedClient.AddDocumentCalls())
func (mock *ClientMock) AddDocumentCalls() []struct {
	Ctx        context.Context
	IndexName  string
	DocumentID string
	Document   []byte
	Opts       *client.AddDocumentOptions
} {
	var calls []struct {
		Ctx        context.Context
		IndexName  string
		DocumentID string
		Document   []byte
		Opts       *client.AddDocumentOptions
	}
	mock.lockAddDocument.RLock()
	calls = mock.calls.AddDocument
	mock.lockAddDocument.RUnlock()
	return calls
}

// BulkIndexAdd calls BulkIndexAddFunc.
func (mock *ClientMock) BulkIndexAdd(ctx context.Context, action client.BulkIndexerAction, index string, documentID string, document []byte) error {
	if mock.BulkIndexAddFunc == nil {
		panic("ClientMock.BulkIndexAddFunc: method is nil but Client.BulkIndexAdd was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Action     client.BulkIndexerAction
		Index      string
		DocumentID string
		Document   []byte
	}{
		Ctx:        ctx,
		Action:     action,
		Index:      index,
		DocumentID: documentID,
		Document:   document,
	}
	mock.lockBulkIndexAdd.Lock()
	mock.calls.BulkIndexAdd = append(mock.calls.BulkIndexAdd, callInfo)
	mock.lockBulkIndexAdd.Unlock()
	return mock.BulkIndexAddFunc(ctx, action, index, documentID, document)
}

// BulkIndexAddCalls gets all the calls that were made to BulkIndexAdd.
// Check the length with:
//
//	len(mockedClient.BulkIndexAddCalls())
func (mock *ClientMock) BulkIndexAddCalls() []struct {
	Ctx        context.Context
	Action     client.BulkIndexerAction
	Index      string
	DocumentID string
	Document   []byte
} {
	var calls []struct {
		Ctx        context.Context
		Action     client.BulkIndexerAction
		Index      string
		DocumentID string
		Document   []byte
	}
	mock.lockBulkIndexAdd.RLock()
	calls = mock.calls.BulkIndexAdd
	mock.lockBulkIndexAdd.RUnlock()
	return calls
}

// BulkIndexClose calls BulkIndexCloseFunc.
func (mock *ClientMock) BulkIndexClose(contextMoqParam context.Context) error {
	if mock.BulkIndexCloseFunc == nil {
		panic("ClientMock.BulkIndexCloseFunc: method is nil but Client.BulkIndexClose was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockBulkIndexClose.Lock()
	mock.calls.BulkIndexClose = append(mock.calls.BulkIndexClose, callInfo)
	mock.lockBulkIndexClose.Unlock()
	return mock.BulkIndexCloseFunc(contextMoqParam)
}

// BulkIndexCloseCalls gets all the calls that were made to BulkIndexClose.
// Check the length with:
//
//	len(mockedClient.BulkIndexCloseCalls())
func (mock *ClientMock) BulkIndexCloseCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockBulkIndexClose.RLock()
	calls = mock.calls.BulkIndexClose
	mock.lockBulkIndexClose.RUnlock()
	return calls
}

// BulkUpdate calls BulkUpdateFunc.
func (mock *ClientMock) BulkUpdate(ctx context.Context, indexName string, url string, settings []byte) ([]byte, error) {
	if mock.BulkUpdateFunc == nil {
		panic("ClientMock.BulkUpdateFunc: method is nil but Client.BulkUpdate was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		IndexName string
		URL       string
		Settings  []byte
	}{
		Ctx:       ctx,
		IndexName: indexName,
		URL:       url,
		Settings:  settings,
	}
	mock.lockBulkUpdate.Lock()
	mock.calls.BulkUpdate = append(mock.calls.BulkUpdate, callInfo)
	mock.lockBulkUpdate.Unlock()
	return mock.BulkUpdateFunc(ctx, indexName, url, settings)
}

// BulkUpdateCalls gets all the calls that were made to BulkUpdate.
// Check the length with:
//
//	len(mockedClient.BulkUpdateCalls())
func (mock *ClientMock) BulkUpdateCalls() []struct {
	Ctx       context.Context
	IndexName string
	URL       string
	Settings  []byte
} {
	var calls []struct {
		Ctx       context.Context
		IndexName string
		URL       string
		Settings  []byte
	}
	mock.lockBulkUpdate.RLock()
	calls = mock.calls.BulkUpdate
	mock.lockBulkUpdate.RUnlock()
	return calls
}

// Checker calls CheckerFunc.
func (mock *ClientMock) Checker(ctx context.Context, state *health.CheckState) error {
	if mock.CheckerFunc == nil {
		panic("ClientMock.CheckerFunc: method is nil but Client.Checker was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		State *health.CheckState
	}{
		Ctx:   ctx,
		State: state,
	}
	mock.lockChecker.Lock()
	mock.calls.Checker = append(mock.calls.Checker, callInfo)
	mock.lockChecker.Unlock()
	return mock.CheckerFunc(ctx, state)
}

// CheckerCalls gets all the calls that were made to Checker.
// Check the length with:
//
//	len(mockedClient.CheckerCalls())
func (mock *ClientMock) CheckerCalls() []struct {
	Ctx   context.Context
	State *health.CheckState
} {
	var calls []struct {
		Ctx   context.Context
		State *health.CheckState
	}
	mock.lockChecker.RLock()
	calls = mock.calls.Checker
	mock.lockChecker.RUnlock()
	return calls
}

// Count calls CountFunc.
func (mock *ClientMock) Count(ctx context.Context, count client.Count) ([]byte, error) {
	if mock.CountFunc == nil {
		panic("ClientMock.CountFunc: method is nil but Client.Count was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Count client.Count
	}{
		Ctx:   ctx,
		Count: count,
	}
	mock.lockCount.Lock()
	mock.calls.Count = append(mock.calls.Count, callInfo)
	mock.lockCount.Unlock()
	return mock.CountFunc(ctx, count)
}

// CountCalls gets all the calls that were made to Count.
// Check the length with:
//
//	len(mockedClient.CountCalls())
func (mock *ClientMock) CountCalls() []struct {
	Ctx   context.Context
	Count client.Count
} {
	var calls []struct {
		Ctx   context.Context
		Count client.Count
	}
	mock.lockCount.RLock()
	calls = mock.calls.Count
	mock.lockCount.RUnlock()
	return calls
}

// CountIndices calls CountIndicesFunc.
func (mock *ClientMock) CountIndices(ctx context.Context, indices []string) ([]byte, error) {
	if mock.CountIndicesFunc == nil {
		panic("ClientMock.CountIndicesFunc: method is nil but Client.CountIndices was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Indices []string
	}{
		Ctx:     ctx,
		Indices: indices,
	}
	mock.lockCountIndices.Lock()
	mock.calls.CountIndices = append(mock.calls.CountIndices, callInfo)
	mock.lockCountIndices.Unlock()
	return mock.CountIndicesFunc(ctx, indices)
}

// CountIndicesCalls gets all the calls that were made to CountIndices.
// Check the length with:
//
//	len(mockedClient.CountIndicesCalls())
func (mock *ClientMock) CountIndicesCalls() []struct {
	Ctx     context.Context
	Indices []string
} {
	var calls []struct {
		Ctx     context.Context
		Indices []string
	}
	mock.lockCountIndices.RLock()
	calls = mock.calls.CountIndices
	mock.lockCountIndices.RUnlock()
	return calls
}

// CreateIndex calls CreateIndexFunc.
func (mock *ClientMock) CreateIndex(ctx context.Context, indexName string, indexSettings []byte) error {
	if mock.CreateIndexFunc == nil {
		panic("ClientMock.CreateIndexFunc: method is nil but Client.CreateIndex was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		IndexName     string
		IndexSettings []byte
	}{
		Ctx:           ctx,
		IndexName:     indexName,
		IndexSettings: indexSettings,
	}
	mock.lockCreateIndex.Lock()
	mock.calls.CreateIndex = append(mock.calls.CreateIndex, callInfo)
	mock.lockCreateIndex.Unlock()
	return mock.CreateIndexFunc(ctx, indexName, indexSettings)
}

// CreateIndexCalls gets all the calls that were made to CreateIndex.
// Check the length with:
//
//	len(mockedClient.CreateIndexCalls())
func (mock *ClientMock) CreateIndexCalls() []struct {
	Ctx           context.Context
	IndexName     string
	IndexSettings []byte
} {
	var calls []struct {
		Ctx           context.Context
		IndexName     string
		IndexSettings []byte
	}
	mock.lockCreateIndex.RLock()
	calls = mock.calls.CreateIndex
	mock.lockCreateIndex.RUnlock()
	return calls
}

// DeleteIndex calls DeleteIndexFunc.
func (mock *ClientMock) DeleteIndex(ctx context.Context, indexName string) error {
	if mock.DeleteIndexFunc == nil {
		panic("ClientMock.DeleteIndexFunc: method is nil but Client.DeleteIndex was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		IndexName string
	}{
		Ctx:       ctx,
		IndexName: indexName,
	}
	mock.lockDeleteIndex.Lock()
	mock.calls.DeleteIndex = append(mock.calls.DeleteIndex, callInfo)
	mock.lockDeleteIndex.Unlock()
	return mock.DeleteIndexFunc(ctx, indexName)
}

// DeleteIndexCalls gets all the calls that were made to DeleteIndex.
// Check the length with:
//
//	len(mockedClient.DeleteIndexCalls())
func (mock *ClientMock) DeleteIndexCalls() []struct {
	Ctx       context.Context
	IndexName string
} {
	var calls []struct {
		Ctx       context.Context
		IndexName string
	}
	mock.lockDeleteIndex.RLock()
	calls = mock.calls.DeleteIndex
	mock.lockDeleteIndex.RUnlock()
	return calls
}

// DeleteIndices calls DeleteIndicesFunc.
func (mock *ClientMock) DeleteIndices(ctx context.Context, indices []string) error {
	if mock.DeleteIndicesFunc == nil {
		panic("ClientMock.DeleteIndicesFunc: method is nil but Client.DeleteIndices was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Indices []string
	}{
		Ctx:     ctx,
		Indices: indices,
	}
	mock.lockDeleteIndices.Lock()
	mock.calls.DeleteIndices = append(mock.calls.DeleteIndices, callInfo)
	mock.lockDeleteIndices.Unlock()
	return mock.DeleteIndicesFunc(ctx, indices)
}

// DeleteIndicesCalls gets all the calls that were made to DeleteIndices.
// Check the length with:
//
//	len(mockedClient.DeleteIndicesCalls())
func (mock *ClientMock) DeleteIndicesCalls() []struct {
	Ctx     context.Context
	Indices []string
} {
	var calls []struct {
		Ctx     context.Context
		Indices []string
	}
	mock.lockDeleteIndices.RLock()
	calls = mock.calls.DeleteIndices
	mock.lockDeleteIndices.RUnlock()
	return calls
}

// GetAlias calls GetAliasFunc.
func (mock *ClientMock) GetAlias(ctx context.Context) ([]byte, error) {
	if mock.GetAliasFunc == nil {
		panic("ClientMock.GetAliasFunc: method is nil but Client.GetAlias was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAlias.Lock()
	mock.calls.GetAlias = append(mock.calls.GetAlias, callInfo)
	mock.lockGetAlias.Unlock()
	return mock.GetAliasFunc(ctx)
}

// GetAliasCalls gets all the calls that were made to GetAlias.
// Check the length with:
//
//	len(mockedClient.GetAliasCalls())
func (mock *ClientMock) GetAliasCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAlias.RLock()
	calls = mock.calls.GetAlias
	mock.lockGetAlias.RUnlock()
	return calls
}

// GetIndices calls GetIndicesFunc.
func (mock *ClientMock) GetIndices(ctx context.Context, indexPatterns []string) ([]byte, error) {
	if mock.GetIndicesFunc == nil {
		panic("ClientMock.GetIndicesFunc: method is nil but Client.GetIndices was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		IndexPatterns []string
	}{
		Ctx:           ctx,
		IndexPatterns: indexPatterns,
	}
	mock.lockGetIndices.Lock()
	mock.calls.GetIndices = append(mock.calls.GetIndices, callInfo)
	mock.lockGetIndices.Unlock()
	return mock.GetIndicesFunc(ctx, indexPatterns)
}

// GetIndicesCalls gets all the calls that were made to GetIndices.
// Check the length with:
//
//	len(mockedClient.GetIndicesCalls())
func (mock *ClientMock) GetIndicesCalls() []struct {
	Ctx           context.Context
	IndexPatterns []string
} {
	var calls []struct {
		Ctx           context.Context
		IndexPatterns []string
	}
	mock.lockGetIndices.RLock()
	calls = mock.calls.GetIndices
	mock.lockGetIndices.RUnlock()
	return calls
}

// MultiSearch calls MultiSearchFunc.
func (mock *ClientMock) MultiSearch(ctx context.Context, searches []client.Search, queryParams *client.QueryParams) ([]byte, error) {
	if mock.MultiSearchFunc == nil {
		panic("ClientMock.MultiSearchFunc: method is nil but Client.MultiSearch was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Searches    []client.Search
		QueryParams *client.QueryParams
	}{
		Ctx:         ctx,
		Searches:    searches,
		QueryParams: queryParams,
	}
	mock.lockMultiSearch.Lock()
	mock.calls.MultiSearch = append(mock.calls.MultiSearch, callInfo)
	mock.lockMultiSearch.Unlock()
	return mock.MultiSearchFunc(ctx, searches, queryParams)
}

// MultiSearchCalls gets all the calls that were made to MultiSearch.
// Check the length with:
//
//	len(mockedClient.MultiSearchCalls())
func (mock *ClientMock) MultiSearchCalls() []struct {
	Ctx         context.Context
	Searches    []client.Search
	QueryParams *client.QueryParams
} {
	var calls []struct {
		Ctx         context.Context
		Searches    []client.Search
		QueryParams *client.QueryParams
	}
	mock.lockMultiSearch.RLock()
	calls = mock.calls.MultiSearch
	mock.lockMultiSearch.RUnlock()
	return calls
}

// NewBulkIndexer calls NewBulkIndexerFunc.
func (mock *ClientMock) NewBulkIndexer(contextMoqParam context.Context) error {
	if mock.NewBulkIndexerFunc == nil {
		panic("ClientMock.NewBulkIndexerFunc: method is nil but Client.NewBulkIndexer was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockNewBulkIndexer.Lock()
	mock.calls.NewBulkIndexer = append(mock.calls.NewBulkIndexer, callInfo)
	mock.lockNewBulkIndexer.Unlock()
	return mock.NewBulkIndexerFunc(contextMoqParam)
}

// NewBulkIndexerCalls gets all the calls that were made to NewBulkIndexer.
// Check the length with:
//
//	len(mockedClient.NewBulkIndexerCalls())
func (mock *ClientMock) NewBulkIndexerCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockNewBulkIndexer.RLock()
	calls = mock.calls.NewBulkIndexer
	mock.lockNewBulkIndexer.RUnlock()
	return calls
}

// Search calls SearchFunc.
func (mock *ClientMock) Search(ctx context.Context, search client.Search) ([]byte, error) {
	if mock.SearchFunc == nil {
		panic("ClientMock.SearchFunc: method is nil but Client.Search was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Search client.Search
	}{
		Ctx:    ctx,
		Search: search,
	}
	mock.lockSearch.Lock()
	mock.calls.Search = append(mock.calls.Search, callInfo)
	mock.lockSearch.Unlock()
	return mock.SearchFunc(ctx, search)
}

// SearchCalls gets all the calls that were made to Search.
// Check the length with:
//
//	len(mockedClient.SearchCalls())
func (mock *ClientMock) SearchCalls() []struct {
	Ctx    context.Context
	Search client.Search
} {
	var calls []struct {
		Ctx    context.Context
		Search client.Search
	}
	mock.lockSearch.RLock()
	calls = mock.calls.Search
	mock.lockSearch.RUnlock()
	return calls
}

// UpdateAliases calls UpdateAliasesFunc.
func (mock *ClientMock) UpdateAliases(ctx context.Context, alias string, removeIndices []string, addIndices []string) error {
	if mock.UpdateAliasesFunc == nil {
		panic("ClientMock.UpdateAliasesFunc: method is nil but Client.UpdateAliases was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Alias         string
		RemoveIndices []string
		AddIndices    []string
	}{
		Ctx:           ctx,
		Alias:         alias,
		RemoveIndices: removeIndices,
		AddIndices:    addIndices,
	}
	mock.lockUpdateAliases.Lock()
	mock.calls.UpdateAliases = append(mock.calls.UpdateAliases, callInfo)
	mock.lockUpdateAliases.Unlock()
	return mock.UpdateAliasesFunc(ctx, alias, removeIndices, addIndices)
}

// UpdateAliasesCalls gets all the calls that were made to UpdateAliases.
// Check the length with:
//
//	len(mockedClient.UpdateAliasesCalls())
func (mock *ClientMock) UpdateAliasesCalls() []struct {
	Ctx           context.Context
	Alias         string
	RemoveIndices []string
	AddIndices    []string
} {
	var calls []struct {
		Ctx           context.Context
		Alias         string
		RemoveIndices []string
		AddIndices    []string
	}
	mock.lockUpdateAliases.RLock()
	calls = mock.calls.UpdateAliases
	mock.lockUpdateAliases.RUnlock()
	return calls
}
